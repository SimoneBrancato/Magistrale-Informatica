# Sistemi Robotici

[TOC]

## Lezione 1 - Introduzione ai Sistemi Dinamici

Contenuti generali del corso.

Riferimenti:

- Course Slides 
- R. Siegwart, I. R. Nourbakhsh, Introduction to Autonomous Mobile Robots, The MIT Press
- Peter Corke, Robotics, Vision and Control: Fundamental Algorithms in MATLAB, Springer 
- Papers provided by the teacher 
- Internet resource

Esame con progetto o scritto + orale.

Un **sistema** è un insieme di elementi che, considerati nel loro complesso, interagiscono tra loro e con l’ambiente secondo determinate leggi. Può essere rappresentato come una **black box** con comportamento $f$ che interagisce con l’ambiente attraverso la ricezione di un input/stimolo $u$ e la produzione di un output/risposta $y$. Ovviamente l'input è variabile nel tempo quindi si definisce $u(t)$ e $y(t)$. Pertanto:
$$
f(u(t))=y(t)
$$
La legge dipende dalle caratteristiche del sistema, come sono implementate e come queste interagiscono tra loro. Può essere una funzione matematica, un algoritmo o qualsiasi altra astrazione che può rappresentare il comportamento del sistema. Infatti, in accordo con la legge del sistema, quest'ultimo può essere statico o dinamico (dal punto di vista temporale, non del "movimento").

Se in due istanti di tempo 

**Esempio Sistema Statico.** Si ha:

![](.\img\esempiostatico.png)

- $u=[a,b]$ con $a,b\in \{0,1\}$
- $y\in\{0,1\}$
- $y=ab+\overline a \overline b$

Notiamo che l'output dipende totalmente dall'input istantaneo, se questo varia nel tempo allora l'output si comporta di conseguenza.
Dati due istanti $t\ne t'$ se $u(t)=u(t')$ allora $y(t)=y(t')$ quindi il tempo non ha effetto e l'output non dipende dal passato.

**Esempio Sistema Dinamico.** Immaginiamo di dover descrivere un sistema dove rappresentiamo una palla su un campo da gioco. 

- L'input sarà la forza applicata sul pallone dal calcio
- L'output sarà velocità e posizione della palla
- La legge sarà la fisica che descrive velocità e posizione secondo dopo secondo

Quando stiamo calciando il pallone applichiamo una forza impulsiva all'istante di tempo $t=0$ ma per $t>0$ l'input è nullo. Ovviamente al tempo zero la velocità cresce subito e inizia a decrescere subito dopo, eventualmente raggiungendo un valore nullo. La posizione invece incrementa secondo dopo secondo, eventualmente raggiungendo un valore costante. Ovviamente in questo contesto dati  $t\ne t'$ se $u(t)=u(t')$ allora $y(t)\ne y(t')$ quindi il tempo ha effetto e l'output dipende anche dal passato.

Formalmente:

- Nei sistemi statici la legge dipende solo dall'input quindi $y(t) = f(u(t))$
- Nei sistemi dinamici la legge dipende anche dal tempo quindi $y(t)=f(u(t),t)$ e si esprimono con un sistema di equazioni differenziali

Dato che consideriamo sistemi della vita reale, questi evolvono nel tempo che è una quantità appartenente ai reali ed evolve continuamente. Questo concetto non può essere implementato in un computer quindi dividiamo il tempo in quanti (Time Quanta), quindi discretizzandolo. Ogni evento si verifica  in uno specifico quanto. Stiamo praticamente applicando il campionamento alla realtà per ogni $\Delta t$, tale pratica si chiama discretizzazione. Dobbiamo scegliere tale delta così che tra un quanto e l'altro non succeda quasi nulla, questo dipende dai sistemi considerati. Per esempio, in sistemi meccanici il nostro delta può essere nell'ordine dei millisecondi.

Utilizzeremo la classe DataPlotter definita nel GitHub del corso in `lib/data/dataplot.py`.

- `DataPlotter()` → Costruttore della classe.
- `set_x(descr: string)` → Imposta la descrizione dell'asse X.
- `add_y(var: string, descr: string)` → Aggiunge una variabile all'asse Y con una descrizione.
- `append_x(value: float)` → Aggiunge un nuovo valore all'asse X.
- `append_y(var: string, value: float)` → Aggiunge un nuovo valore alla variabile specificata dell’asse Y.
- `plot()` → Genera il grafico con i dati raccolti.

Degli esempi possono essere visti a:

- `examples/dataplot/dataplot_example.ipynb`
- `examples/dataplot/dataplot_example 2.ipynb`



-----



Vediamo adesso come interagire con un sistema. In un sistema robotico il sistema fisico è connesso con un componente elettronico che prova a far comportare il sistema fisico come desiderato. Tale componente di solito è un computer con un software che invia periodicamente riceve l'output del sistema fisico e genera un segnale di input. La ricezione dell'output viene effettuata con un sensore elettronico che calcola le quantità fisiche e le trasforma in variabili software. Similmente, l'input generato è dirottato verso il sistema fisico mediante driver elettronici in grado di trasformare le variabili software in quantità fisiche. Il software quindi consta di un loop infinito che prende dati dai sensori, li processa e genera nuovi dati per il driver.

![](.\img\driver.png)

Possiamo procedere in due modi:

- **Timer-Based Sampling:** l'acquisizione avviene a intervalli di tempo regolari ($\Delta T$), indipendentemente dalla variazione dei dati. Il tempo di acquisizione è **costante** e indipendente dagli eventi. Utile per controlli periodici.

  ```pseudocode
  def Timer-Based-Sampling():
      while True do:
          on each ∆T;
          data = read sensors();
          proc_data = process(data, ∆T);
          send_to_driver(proc_data);
  ```

- **Sensor-Based Timing:** L'acquisizione avviene **solo quando il sensore rileva un evento**. Il tempo di acquisizione è **variabile**, dipende dal sensore. Utile per sistemi **event-driven**. Ricevuto il dato calcola il tempo trascorso dall'ultimo evento quindi il delta.

  ```pseudocode
  def Sensor-Based-Timing()
      while True do
          data = wait_sensors();
          compute ∆T; 
          proc_data = process(data, ∆T);
          send_to_driver(proc_data);
  ```

  

  ----

  

Grazie a Godot possiamo fare delle simulazioni dei sistemi fisici, mentre l’elaborazione dei dati e il controllo vengono gestiti da un programma esterno scritto in **Python**. La comunicazione tra i due avviene tramite un **middleware**, che funge da canale di scambio dati. I dati scambiati sono variabili caratterizzati da un nome, un tipo e un valore. 

Il protocollo si basa sul modello Publish-Subscriber, quindi:

- Un peer interessato a una variabile si iscrive indicandone il nome
- Il peer che produce la variabile la pubblica
- Il peer interessato può aspettare la sua pubblicazione o direttamente leggere il valore se disponibile

![](.\img\godot.png)



Useremo la classe `DDS`, ovvero Data Distribution Service definita in `lib/dds/dds.py`, rappresenta un'implementazione di un middleware.

- `DDS()` → Costruttore della classe.
- `start()` → Avvia il servizio DDS.
- `subscribe(var_list: list[str])` → Sottoscrive alle variabili specificate, permettendo di ricevere aggiornamenti quando vengono pubblicate.
- `publish(name: str, value: float | int, type)`→ Pubblica una variabile con un valore specificato. Il tipo può essere:
  - `DDS.DDS_TYPE_INT`
  - `DDS.DDS_TYPE_FLOAT`
- `read(name: str)` → Legge il valore di una variabile pubblicata.
- `wait(name: str)` → Si blocca fino a quando la variabile specificata viene aggiornata, poi la legge.

La classe `Time` è un helper per misurare intervalli temporali. Definita in `lib/utils/time.py`.

- `Time()` → Costruttore, inizializza l’oggetto tempo.
- `start()` → Avvia il conteggio del tempo.
- `get() → float` → Restituisce il tempo trascorso dalla creazione dell'oggetto o dall'ultima chiamata a `start()`.
- `elapsed() → float` → Restituisce l’intervallo di tempo trascorso dall'ultima chiamata a `elapsed()` e aggiorna il riferimento temporale.

Possiamo visionare degli esempi in Godot ai seguenti Python Notebook:

- `examples/godot_plot/godot_ball_test.ipynb`
- `examples/godot_plot/godot_ball_test position.ipynb`



-----



Vediamo adesso alcune implementazioni base. Utilizziamo la classe:

```python
class System:
    
    def __init__(self):
        # initialise members
        
    def evaluate(self, delta_t : float, _input : any): -> any
        # implement a delta_t computation step using _input
        # and generate _output
        ...
        return _output
```

Immaginiamo di avere un sistema semplice dove abbiamo un sensore di posizione ma abbiamo bisogno anche della velocità. Sapendo che la velocità è la derivata prima della posizione rispetto al tempo, possiamo andare a trovarne l'equazione corrispondente.

![](.\img\velocity.png)

Quella che vediamo è la notazione puntata, infatti il punto sopra una variabile rappresenta la derivata rispetto al tempo quindi:
$$
\dot p = \frac{dp}{dt}=v
$$
Mentre due punti rappresentano ovviamente la derivata seconda. Sapendo che l'accelerazione è la derivata prima della velocità, si ha:
$$
\ddot p = \frac{d^2p}{d^2t}=\dot v= a
$$
Ovviamente per implementare la derivata possiamo utilizzare il rapporto incrementale:
$$
\dot u \simeq \frac {u(t+\Delta T)-u(t)}{\Delta T}
$$
Possiamo usare la classe Derivator per implementare questo comportamento:

```python
class Derivator:
    
    def __init__(self):
    	self.prev_input = 0
        
    def evaluate(self, delta_t, _input):
        out = (_input - self.prev_input) / delta_t  # Rapporto incrementale
        self.prev_input = _input
        return out 
```

Un esempio di derivata può essere visto qui: `examples/basic/godot_ball_test_derivative.ipynb`

Ovviamente possiamo fare anche l'operazione inversa: l'integrale. Avendo un sensore che trova la velocità possiamo risalire alla posizione integrando l'equazione corrispondente.

![](.\img\int.png)

Per implementare l'integrale basta considerare che è l'inversa della derivata
$$
u(t)=\frac{y(t+\Delta T)-y(t)}{\Delta T} 
\rightarrow\ y(t+\Delta T)=y(t)+u(t)*\Delta T
$$
Possiamo usare:

```python
class Integrator:
    
    def __init__(self):
    	self.prev_output = 0
    
    def evaluate(self, delta_t, _input):
        out = self.prev_output + _input * delta_t
        self.prev_output = out
        return out
```

Un esempio: `examples/basic/godot_ball_test_integral.ipynb`



----



Se un **sensore** fornisce dati in un'unità di misura diversa da quella richiesta, dobbiamo moltiplicare il valore letto per un **fattore di conversione** $K$, che è il **guadagno** del sistema. Matematicamente, se il sensore fornisce un valore $u(t)$ e vogliamo ottenere un valore $y(t)$ nella scala corretta, usiamo la relazione:
$$
y(t)= K_pu(t)
$$

```python
class Proportional:
    
    def __init__(self, _kp):
    	self.kp = _kp
        
    def evaluate(self, delta_t, _input):
    	return _input * self.kp
```



Riassumendo quindi, qualsiasi sistema dinamico lineare e invariante nel tempo (il suo comportamento non varia nel tempo)può essere rappresentato come combinazione lineare dei seguenti sistemi base: proporzionale, integrale e derivata.



----



Ovviamente i sistemi possono essere combinati, per esempio possiamo metterli in serie:

```python
class Series:
    
    def __init__(self):
        self.s1 = System(...)
        self.s2 = System(...)
        
    def evaluate(self, delta_t, _input):
        out_s1 = self.s1.evaluate(delta_t, _input)
        out_s2 = self.s2.evaluate(delta_t, out_s1)
        return out_s2
```

Possiamo metterli in parallelo, sia sommando i risultati che sottraendoli:

```python
class Parallel:
    
    def __init__(self):
        self.s1 = System(...)
        self.s2 = System(...)
        
    def evaluate(self, delta_t, _input):
        out_s1 = self.s1.evaluate(delta_t, _input)
        out_s2 = self.s2.evaluate(delta_t, _input) 
        out = out_s1 + out_s2 #Potremmo anche sottrarli, dipende dal contesto
        return out
```



----



Qualora avessimo bisogno di implementare il concetto di memoria, è necessario il cosiddetto Feedback. In questo modo verrà considerato il precedente valore di output in modo tale da tenerne conto nel successivo input. 

![](C:\Users\simon\Desktop\Magistrale-Informatica\Simone\0105 Sistemi Robotici\img\feedback.png)

```python
class Feedback:
    
    def __init__(self):
        self.s1 = System(...)
        self.s2 = System(...)
        self.prev_out = 0
        
    def evaluate(self, delta_t, _input):
        out_s2 = self.s2.evaluate(delta_t, self.prev_out)
        input_s1 = out_s2 + _input
        out = self.s1.evaluate(delta_t, input_s1)
        self.prev_out = out
        return out
```

Notiamo che  il componente S2 è atto alla rielaborazione del precedente output, dipende dal contesto.

Infine, ovviamente i sistemi possono essere composti. Vediamo un primo esempio:

![](.\img\comp.png)



```python
class Compound:
    def __init__(self):
        self.s1 = Proportional(K1)
        self.s2 = Proportional(K2)
        self.s3 = Derivator()
        self.s4 = Integrator()
        self.y1 = 0
    
    def evaluate(self, delta_t, _input):
        out_s1 = self.s1.evaluate(delta_t, _input)
        out_s3 = self.s3.evaluate(delta_t, self.y1)
        out_s2 = self.s2.evaluate(delta_t, out_s3)
        
        y1 = out_s1 - out_s2
        y2 = self.s4.evaluate(delta_t, y1)
        
        self.y1 = y1
        return (y1, y2)
```



## Lezione 2 - Modellare un carrello

Immaginiamo di avere un carrello che si muove in uno spazio monodimensionale. Avrà massa $M$ ed è equipaggiato con un motore elettrico. All'istante $t=0$ accendiamo i motori che forniscono una certa trazione $F(t)$. Come si comporta il carrello? Qual è l'andamento della velocità nel tempo? Qual è la sua posizione secondo dopo secondo?

![](.\img\cart.png)

**Secondo principio della dinamica:** la somma delle forze in un corpo rigido è uguale alla massa del corpo moltiplicata all'accelerazione
$$
\sum \vec f(t) = M\vec a(t)
$$
Oltre alla forza applicata dalla trazionen consideriamo anche la resistenza dell'aria che dipende dalla velocità ed è opposta in direzione. A bassi regimi la resistenza dell'aria può essere descritta dalla legge di Strokes:
$$
f_a(t)=-Bv(t)
$$
dove $B$ è la costante che dipende dalla viscosità del fluido e dalla forma del corpo rigido. Pertanto il modello generale è descrivibile in formula:
$$
F(t)-Bv(t) = Ma(t)
$$
Sapendo che $a(t)=\dot v(t)$ si ha:
$$
F(t)-Bv(t) = M \dot v(t)
$$
Che è un'equazione differenziale che dipende dalla definizione formale di $F(t)$, e può essere implementata usando una combinazione di sistemi proporzionali e derivativi. Riordinando infatti:
$$
v(t)=\frac1B F(t)-\frac MB\dot v(t)
$$
![](C:\Users\simon\Desktop\Magistrale-Informatica\Simone\0105 Sistemi Robotici\img\cart2.png)

Alternativamente possiamo discretizzare l'equazione differenziale:
$$
\dot v(t)=\frac 1MF(t)-\frac BM v(t) \\
\frac{v(t+\Delta T)-v(t)}{\Delta T}=\frac 1M F(t) - \frac BM v(t) \\
... \\
v(t+\Delta T)=v(t)\Bigg (1-\frac{B\Delta T}{M} \Bigg) + \frac{\Delta T}{M}F(t) \ \ \ \ \  \ \big(*\big)
$$
Quest'ultima equazione può essere interpretata come: il nuovo valore della velocità dipende dal valore precedente della velocità e l'input applicato.

Considerando anche la posizione che è l'integrale della velocità possiamo scrivere:
$$
v(t)=\frac{x(t+\Delta T)-x(t)}{\Delta T}\\
... \\
x(t+\Delta T)=x(t)+ v(t)\Delta T \ \ \ \ \  \ \big(** \big )
$$
Quindi il modello finale consta delle due equazioni $(*)$ e $(**)$.

```python
class Cart:
    def __init__(self, _mass: float, _friction: float):
        self.M: float = _mass
        self.B: float = _friction
        self.speed: float = 0
        self.position: float = 0
        
    def evaluate(self, delta_t: float, _force: float) -> tuple:
        new_speed: float = self.speed*(1-self.B*delta_t/self.M)+delta_t*_force/self.M
        new_position: float = self.position + self.speed * delta_t
        self.speed = new_speed
        self.position = new_position
        return (self.position, self.speed)
```

Esempi:`examples/cart/test_cart_1.ipynb` e `examples/cart/test_cart_2.ipynb`

Possiamo definire la risposta all'impulso cioè:
$$
v(t)\simeq 10e^{\frac34t}
$$
E la step response:
$$
v(t) \simeq 0.3(1-e^{-\frac34 t})
$$
![](.\img\speed.png)

Notiamo dai grafici che c'è un comportamento del carrello asintotico,  cioè si ferma solo quando $t\rightarrow0$.

Nella realtà dopo un calcio al carrello questo si fermerà in un tempo finito, si muove solo quando la forza in input è maggiore di un certo valore (definito dalla massa del carrello, forza d'attrito statica etc.) Nel modello in realtà il carrello si muove anche se la forza applicata è molto bassa. Quindi è considerabile solo come un riferimento della forma del fenomeno. Non siamo interessati alla perfetta forma analitica perchè l'algoritmo che andiamo a definire funzionerebbe anche nel caso reale.

> ChatGPT - Differenza tra impulse e step:
>
> La **risposta all'impulso** misura la reazione del sistema a un cambiamento **istantaneo** e **concentrato nel tempo**.
> La **risposta al gradino** misura la reazione a un cambiamento **persistente e mantenuto nel tempo**.

































